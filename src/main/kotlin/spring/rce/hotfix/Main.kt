/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package spring.rce.hotfix

import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.util.stream.Stream
import java.util.zip.CRC32
import java.util.zip.Checksum
import java.util.zip.ZipEntry
import java.util.zip.ZipEntry.STORED
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream
import kotlin.io.path.isRegularFile
import kotlin.io.path.name


/**
 * Inspect a list of directories, and patch every jar it encounters.
 */
fun main(directories: Array<String>) {
    Stream.of(*directories).flatMap { scanJarsInDirectory(File(it)) }.forEach { patch(it) }
}

/**
 * Patch a jar bytes, and return a pair of (vulnerabilityFound, the patched jar bytes).
 */
private fun patchJarBytes(name: String, inputJarBytes: ByteArray): Pair<Boolean, ByteArray> {
    try {
        var vulnerabilityFound = false
        val bos = ByteArrayOutputStream()
        ZipOutputStream(bos).use { zipOutput ->
            ZipInputStream(ByteArrayInputStream(inputJarBytes)).use { zipInput ->
                var entry = zipInput.nextEntry
                while (entry != null) {
                    val entryBytes = zipInput.readBytes()
                    val patchedBytes = if (entry.name.endsWith(".jar")) {
                        val patchedJarBytes = patchJarBytes("$name-${entry.name.substringAfterLast("/")}", entryBytes)
                        vulnerabilityFound = vulnerabilityFound || patchedJarBytes.first
                        patchedJarBytes.second
                    } else if (entry.name.endsWith("org/springframework/validation/DataBinder.class")) {
                        vulnerabilityFound = true
                        println("Found vulnerable DataBinder.class in $name, patching...")
                        val cr = ClassReader(ByteArrayInputStream(entryBytes))
                        val cw = ClassWriter(ClassWriter.COMPUTE_FRAMES)
                        cr.accept(PatchDataBinderClassVisitor(cw), 0)
                        cw.toByteArray()
                    } else {
                        entryBytes
                    }
                    zipOutput.putNextEntry(ZipEntry(entry.name).apply {
                        //  Unable to open nested entry 'BOOT-INF/lib/spring-boot-2.5.11.jar'. It has been compressed and nested jar files must be stored without compression. Please check the mechanism used to create your executable jar file
                        method = STORED
                        size = patchedBytes.size.toLong()
                        val checksum: Checksum = CRC32().apply { update(patchedBytes) }
                        crc = checksum.value
                    })
                    zipOutput.write(patchedBytes)
                    zipOutput.closeEntry()
                    zipInput.closeEntry()
                    entry = zipInput.nextEntry
                }
            }
        }
        return (vulnerabilityFound to bos.toByteArray())
    } catch (e: Exception) {
        System.err.println("Failed to patch $name: ${e.stackTraceToString()}")
        return (false to inputJarBytes)
    }
}

private fun patch(path: Path) {
    val (vulnerabilityFound, patchedBytes) = patchJarBytes(path.name, path.toFile().readBytes())
    if (vulnerabilityFound) {
        println("Successfully patched $path.")
        path.toFile().writeBytes(patchedBytes)
    } else {
        println("Vulnerability not found in $path.")
    }
}

private fun scanJarsInDirectory(fileOrDirectory: File): Stream<Path> {
    if (fileOrDirectory.isFile && fileOrDirectory.name.endsWith(".jar")) {
        return Stream.of(fileOrDirectory.toPath())
    }
    if (!fileOrDirectory.isDirectory) {
        return Stream.empty()
    }
    return Files.walk(fileOrDirectory.toPath())
        .filter { it.isRegularFile() && it.name.endsWith(".jar") }
}
